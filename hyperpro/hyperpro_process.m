% hyperpro_process.m - Process HyperPro data from compiled *.mat files
%
% Syntax: hyperpro_process.m
%
% Script performs dark corrections, interpolates pressure, tilt and velocity
%     data to match to Ed and interpolates wavelengths across sensors to be 
%     consistent with Ed; r-squared values for the regression of pressure
%     versus log(Edz) and log(Luz) are also determined for later QA/QC
%
% Inputs:
%    1) Folder location with compiled HyperPro data generated using 'hyperpro_matfile_compile.m'
%
% Outputs:
%    output - 'GC#_hyperpro_processed.mat' file for cruise with processed 
%    HyperPro data ('GC#' is the cruise designation)
%   
% MAT-files required: 'GC#_all_hyperpro.mat' generated by 'hyperpro_matfile_compile.m'
%
% Author: Steven E. Lohrenz, Ph.D., biological oceanography
% School for Marine Science and Technology, University of Massachusetts Dartmouth
% email address: slohrenz@umassd.edu
% Website: http://www.umassd.edu/smast/
% Last revision: 25 Aug 2025 

%% ------------- BEGIN CODE --------------%% 


clc

% For batch processing, commment statement out below
% icr = 5;

crz = ['GC',num2str(icr)];

switch crz
        % inputfolder='...\GulfCarbon\GC_hypersensor_data\Gulf Carbon 1\Hyperpro_Data\';
        case 'GC2'
            inputfolder = '...\GulfCarbon\GC_hypersensor_data\GC2_Hyper_sensors\GC2_hyperPro_data\';
        case 'GC3'
            inputfolder='...\GulfCarbon\GC_hypersensor_data\GC3_hypersensors\HyperPro_GC3\';
        case 'GC4'
            inputfolder='...\GulfCarbon\GC_hypersensor_data\GC4_hyper\HyperPro_data_GC4\';
        case 'GC5'
            inputfolder='...\GulfCarbon\GC_hypersensor_data\GC5_hyperPro\';
    end

cruise_txt = crz;

load([inputfolder,cruise_txt,'_all_hyperpro.mat']);

[~,m]= size(hyperpro_struct);

lat=zeros(m,1);
lon=zeros(m,1);
pres_tare=zeros(m,1);
pro_group=zeros(m,1);
pro_date=NaT(m,1);
pro_datestr=cell(m,1);
pro_station=cell(m,1);
ed_corr=cell(m,1);
lu_corr_interp=cell(m,1);
es_corr_interp=cell(m,1);
eu1_corr_interp=cell(m,1);
eu2_corr_interp=cell(m,1);
pres_interp=cell(m,1);
pres_interp_corr=cell(m,1);
pro_tilt=cell(m,1); 
pro_vel=cell(m,1);  
input_file=cell(m,1);  
field_names = cell(m,1);

%date_format='eee MMM dd HH:mm:ss yyyy';
new_date_format='MM/dd/yyyy HH:mm:ss';

old_lat=0;
old_lon=0;

%% Loop through profiles and group by station
    
for nprofile=1:m    
    
    if hyperpro_struct(nprofile).attributes.group_id==-9999  % Eliminate -9999 group profiles (bad)
        continue
    end
    pro_group(nprofile)=hyperpro_struct(nprofile).attributes.group_id;
    pro_date(nprofile)=hyperpro_struct(nprofile).attributes.date;
    pro_datestr(nprofile)={string(pro_date(nprofile),new_date_format)};
    lat(nprofile)=hyperpro_struct(nprofile).attributes.lat;
    lon(nprofile)=hyperpro_struct(nprofile).attributes.lon;
    pres_tare(nprofile)=hyperpro_struct(nprofile).attributes.pres_tare;
    pro_station(nprofile)=hyperpro_struct(nprofile).attributes.station_id;
    input_file{nprofile}=hyperpro_struct(nprofile).attributes.input_file;
    field_names{nprofile} = fieldnames(hyperpro_struct(nprofile));

    % if isempty(hyperpro_struct(nprofile).lu) || isempty(hyperpro_struct(nprofile).edd)
    %     continue
    % end
    
    ed_uncorr=hyperpro_struct(nprofile).ed.data;
    ed_lambda=hyperpro_struct(nprofile).ed.lambda;
    ed_timer=hyperpro_struct(nprofile).ed.timer;
    ed_date=hyperpro_struct(nprofile).ed.date;
    ed_time=hyperpro_struct(nprofile).ed.time;
    
    lu_uncorr=hyperpro_struct(nprofile).lu.data;
    lu_lambda=hyperpro_struct(nprofile).lu.lambda;
    lu_timer=hyperpro_struct(nprofile).lu.timer;
    lu_date=hyperpro_struct(nprofile).lu.date;
    lu_time=hyperpro_struct(nprofile).lu.time;
    
    pres=hyperpro_struct(nprofile).mpr.pres;
    pres_timer=hyperpro_struct(nprofile).mpr.timer;
    vel=hyperpro_struct(nprofile).mpr.vel;
    pres_date=hyperpro_struct(nprofile).mpr.date;
    pres_time=hyperpro_struct(nprofile).mpr.time;
    tilt=hyperpro_struct(nprofile).mpr.tilt;
    
    edd_lambda=hyperpro_struct(nprofile).edd.lambda;
    edd=hyperpro_struct(nprofile).edd.data;
    edd_timer=hyperpro_struct(nprofile).edd.timer;
    edd_date=hyperpro_struct(nprofile).edd.date;
    edd_time=hyperpro_struct(nprofile).edd.time;

    if ~isempty(hyperpro_struct(nprofile).lud)
        lud_lambda=hyperpro_struct(nprofile).lud.lambda;
        lud=hyperpro_struct(nprofile).lud.data;
        lud_timer=hyperpro_struct(nprofile).lud.timer;
        lud_date=hyperpro_struct(nprofile).lud.date;
        lud_time=hyperpro_struct(nprofile).lud.time;
    else
        lud_lambda=[];
        lud_uncorr=[];
        lud_timer=[];
        lud_date=[];
        lud_time=[];
    end
    
    es_lambda=hyperpro_struct(nprofile).es.lambda;
    es_uncorr=hyperpro_struct(nprofile).es.data;
    es_timer=hyperpro_struct(nprofile).es.timer;
    es_date=hyperpro_struct(nprofile).es.date;
    es_time=hyperpro_struct(nprofile).es.time;

    esd_lambda=hyperpro_struct(nprofile).esd.lambda;
    esd=hyperpro_struct(nprofile).esd.data;
    esd_timer=hyperpro_struct(nprofile).esd.timer;
    esd_date=hyperpro_struct(nprofile).esd.date;
    esd_time=hyperpro_struct(nprofile).esd.time;
    
    if ~isempty(hyperpro_struct(nprofile).eu1)
        eu1_lambda=hyperpro_struct(nprofile).eu1.lambda;
        eu1_uncorr=hyperpro_struct(nprofile).eu1.data;
        eu1_timer=hyperpro_struct(nprofile).eu1.timer;
        eu1_date=hyperpro_struct(nprofile).eu1.date;
        eu1_time=hyperpro_struct(nprofile).eu1.time;
    else
        eu1_lambda=[];
        eu1_uncorr=[];
        eu1_timer=[];
        eu1_date=[];
        eu1_time=[];
    end

    if ~isempty(hyperpro_struct(nprofile).eu1d)
        eu1d_lambda=hyperpro_struct(nprofile).eu1d.lambda;
        eu1d=hyperpro_struct(nprofile).eu1d.data;
        eu1d_timer=hyperpro_struct(nprofile).eu1d.timer;
        eu1d_date=hyperpro_struct(nprofile).eu1d.date;
        eu1d_time=hyperpro_struct(nprofile).eu1d.time;
    else
        eu1d_lambda=[];
        eu1d_uncorr=[];
        eu1d_timer=[];
    end
    
    if contains(field_names{nprofile},'eu2')
        eu2_lambda=hyperpro_struct(nprofile).eu2.lambda;
        eu2_uncorr=hyperpro_struct(nprofile).eu2.data;
        eu2_timer=hyperpro_struct(nprofile).eu2.timer;
        eu2_date=hyperpro_struct(nprofile).eu2.date;
        eu2_time=hyperpro_struct(nprofile).eu2.time;
    else
        eu2_lambda=[];
        eu2_uncorr=[];
        eu2_timer=[];
        eu2_date=[];
        eu2_time=[];
    end

    if contains(field_names{nprofile},'eu2d')
        eu2d_lambda=hyperpro_struct(nprofile).eu2d.lambda;
        eu2d=hyperpro_struct(nprofile).eu2d.data;
        eu2d_timer=hyperpro_struct(nprofile).eu2d.timer;
        eu2d_date=hyperpro_struct(nprofile).eu2d.date;
        eu2d_time=hyperpro_struct(nprofile).eu2d.time;
    else
        eu2d_lambda=[];
        eu2d_uncorr=[];
        eu2d_timer=[];
    end

    % Interpolate values to be consistent with ed and correct for dark
    
    if isscalar(pres_timer)
        pres_interp{nprofile}=pres;
        pres_interp_corr{nprofile}=pres_interp{nprofile};
    else
        pres_interp{nprofile}=interp1(pres_timer,pres,ed_timer,'linear','extrap');
        pres_interp_corr{nprofile}=pres_interp{nprofile};  %-pres_tare';  %Tare subtraction already done
        pro_tilt{nprofile}=interp1(pres_timer,tilt,ed_timer,'linear','extrap');  
        pro_vel{nprofile}=interp1(pres_timer,vel,ed_timer,'linear','extrap');  
    end
    
    if length(ed_timer)<=1
        ed_corr{nprofile}=[];
        continue
    elseif isscalar(edd_timer)
        edd_interp=edd;
        ed_corr{nprofile}=ed_uncorr-edd_interp;
    else        
        edd_interp=interp1(edd_timer,edd,ed_timer,'nearest','extrap');
        ed_corr{nprofile}=ed_uncorr-edd_interp;
    end
    
    if length(lu_timer)<=1 || isempty(lud) || isempty(lud_timer)
        disp(['empty lud or low lu count: ',char(pro_station(nprofile))]);
        lu_corr=[];
        lu_corr_interp{nprofile}=[];
    elseif isscalar(lud_timer)
        lu_corr=lu_uncorr-lud;  % Subtract vector from matrix
        lu_corr_interp{nprofile}=interp1(lu_timer,lu_corr,ed_timer,'linear','extrap');
    else
        lud_interp=interp1(lud_timer,lud,lu_timer,'nearest','extrap');
        lu_corr=lu_uncorr-lud_interp;
        lu_corr_interp{nprofile}=interp1(lu_timer,lu_corr,ed_timer,'linear','extrap');
    end
    
    if isempty(eu1_uncorr) || isempty(eu1d) || isempty(eu1d_timer)
        eu1_corr=[];
        eu1_corr_interp{nprofile}=[];
    elseif isscalar(eu1d_timer)
        eu1_corr=eu1_uncorr-eu1d;
        eu1_corr_interp{nprofile}=interp1(eu1_timer,eu1_corr,ed_timer,'linear','extrap');
    else
        eu1d_interp=interp1(eu1d_timer,eu1d,eu1_timer,'nearest','extrap');
        eu1_corr=eu1_uncorr-eu1d_interp;
        eu1_corr_interp{nprofile}=interp1(eu1_timer,eu1_corr,ed_timer,'linear','extrap');
    end
    
    if isempty(eu2_uncorr) || isempty(eu2d) || isempty(eu2d_timer)
        eu2_corr=[];
        eu2_corr_interp{nprofile}=[];
    elseif isscalar(eu2d_timer)
        eu2_corr=eu2_uncorr-eu2d;
        eu2_corr_interp{nprofile}=interp1(eu2_timer,eu2_corr,ed_timer,'linear','extrap');
    elseif isscalar(eu2_timer)
        eu2d_interp=interp1(eu2d_timer,eu2d,eu2_timer,'nearest','extrap');
        eu2_corr=eu2_uncorr-eu2d_interp;
        eu2_corr_interp{nprofile}=repmat(eu2_corr,size(ed_timer,1),1);
    else
        eu2d_interp=interp1(eu2d_timer,eu2d,eu2_timer,'nearest','extrap');
        eu2_corr=eu2_uncorr-eu2d_interp;
        eu2_corr_interp{nprofile}=interp1(eu2_timer,eu2_corr,ed_timer,'nearest','extrap');
    end
    
    if isempty(es_uncorr) || isempty(esd) || isempty(esd_timer)
        es_corr=[];
        es_corr_interp{nprofile}=[];
    elseif isscalar(esd_timer)
        es_corr=es_uncorr-esd;
        es_corr_interp{nprofile}=interp1(es_timer,es_corr,ed_timer,'linear','extrap');
    else
        esd_interp=interp1(esd_timer,esd,es_timer,'nearest','extrap');
        es_corr=es_uncorr-esd_interp;

        % Eliminate bad Es values
        es_corr_interp{nprofile}=interp1(es_timer,es_corr,ed_timer,'linear','extrap');
        es_corr_interp{nprofile}(es_corr_interp{nprofile}<10)=NaN;
    end
end

%% Output data in structured variable organized by group

pro_group_struct=struct('pro_date',{},'pro_datestr',{},'pres_tare',{},'pro_lat',{},'pro_lon',{},'pres_interp',{},...
    'pro_tilt',{},'pro_vel',{},'pro_pres',{},'raw_file',{},'ed_corr_es',{},'es_corr_interp',{},'lu_corr_es',{},...
    'eu1_corr_es',{},'eu2_corr_es',{},'k_ed',{},'k_lu',{},'k_es',{},'k_eu1',{},'k_eu2',{},'ed_0',{},...
    'lu_0',{},'lw_0',{},'eu1_0',{},'eu2_0',{},'rrs',{},'ed_lambda',{},'lu_lambda',{},'eu1_lambda',{},...
    'eu2_lambda',{},'es_lambda',{});

for groupn=1:max(pro_group)
        
    group_index=find(pro_group==groupn);
    [pro_num,~]=size(group_index);  % Number of profiles in the group
    
    for loop_index=1:pro_num
        
        pro_index=group_index(loop_index);  % Group index for profile from retrieval loop above
        
        disp(['Processing profile ',num2str(group_index(loop_index)),' in group ',num2str(groupn)]);

        pro_group_struct{groupn}.pro_date(loop_index)=pro_date(pro_index);
        pro_group_struct{groupn}.pro_datestr(loop_index)=pro_datestr{pro_index};
        pro_group_struct{groupn}.pres_tare(loop_index)=pres_tare(pro_index);
        pro_group_struct{groupn}.pres_interp{loop_index}=pres_interp_corr{pro_index};
        pro_group_struct{groupn}.pro_lat(loop_index)=lat(pro_index);
        pro_group_struct{groupn}.pro_lon(loop_index)=lon(pro_index);
        pro_group_struct{groupn}.pro_tilt{loop_index}=pro_tilt{pro_index};
        pro_group_struct{groupn}.pro_vel{loop_index}=pro_vel{pro_index};
        pro_group_struct{groupn}.pro_station{loop_index}=pro_station{pro_index};
        pro_group_struct{groupn}.raw_file{loop_index}=input_file{pro_index};

        [pro_size,~]=size(ed_corr{pro_index});  % Determine number of profile measurements

        % Correct radiometric values for variations in surface irradiance (Zibordi et al. 2012,
        % Ocean Sci. 8, 567586, 2012 (www.ocean-sci.net/8/567/2012/)

        if ~isempty(ed_corr{pro_index})
            ed_corr_es=(ed_corr{pro_index}./es_corr_interp{pro_index}).*repmat(es_corr_interp{pro_index}(1,:),pro_size,1);
        else
            disp(['empty edd: ',char(pro_station(loop_index))]);
            ed_corr_es=[];
        end

        if ~isempty(lu_corr_interp{pro_index})
            lu_corr_es=(lu_corr_interp{pro_index}./es_corr_interp{pro_index}).*repmat(es_corr_interp{pro_index}(1,:),pro_size,1);
        else
            disp(['empty lu: ',char(pro_station(loop_index))]);
            lu_corr_es=[];
        end

        if ~isempty(eu1_corr_interp{pro_index})
            eu1_corr_es=(eu1_corr_interp{pro_index}./es_corr_interp{pro_index}).*repmat(es_corr_interp{pro_index}(1,:),pro_size,1);
        else
            eu1_corr_es=[];
        end
        
        if ~isempty(eu2_corr_interp{pro_index})
            eu2_corr_es=(eu2_corr_interp{pro_index}./es_corr_interp{pro_index}).*repmat(es_corr_interp{pro_index}(1,:),pro_size,1);
        else
            eu2_corr_es=[];
        end

        % Extrapolate values to surface assuming log-linear relationship to
        %   depth
        
        % Find pressures < 2 m for shallow and <5 m for intermediate and <10 m
        %     for deep upper water column attenuation to avoid values at limit of detection
        
        if pres_interp_corr{pro_index}(end)<10 && min(pres_interp_corr{pro_index})<1
            pres_index=find(pres_interp_corr{pro_index}<2);
        elseif pres_interp_corr{pro_index}(end)<40 && min(pres_interp_corr{pro_index})<2
            pres_index=find(pres_interp_corr{pro_index}<5);
        else
            pres_index=find(pres_interp_corr{pro_index}<10);
        end

        % Eliminate negative values and values outside quality thresholds
        ed_corr_es(ed_corr_es<0)=nan;
        lu_corr_es(lu_corr_es<0)=nan;
        if ~isempty(eu1_corr_es)
            eu1_corr_es(eu1_corr_es<0)=nan;
        end
        if ~isempty(eu2_corr_es)
            eu2_corr_es(eu2_corr_es<0)=nan;
        end
        
        % Filter data based on quality criteria % THIS IS TURNED OFF - FILTERING DONE IN SEABASS OUTPUT
        bad_index=find(round(abs(pro_tilt{pro_index}),0,TieBreaker="tozero")>5 | round(pro_vel{pro_index},0)<0.1);
        % ed_corr_es(bad_index,:)=NaN;
        % lu_corr_es(bad_index,:)=NaN;
        if ~isempty(eu1_corr_es)
            eu1_corr_es(bad_index,:)=NaN;
        end        
        if ~isempty(eu2_corr_es)
            eu2_corr_es(bad_index,:)=NaN;
        end        

        k_ed=nan(1,137);
        k_lu=nan(1,137);
        k_eu1=nan(1,137);
        k_eu2=nan(1,137);
        ed_0=nan(1,137);
        lu_0=nan(1,137);
        eu1_0=nan(1,137);
        eu2_0=nan(1,137);
        % lw_0=nan(1,137);
        % rrs=nan(1,137);
        rsqr_ed=nan(1,137);
        rsqr_lu=nan(1,137);
        rsqr_eu1=nan(1,137);
        rsqr_eu2=nan(1,137);

        % Loop through each wavelength and determine r-squared for depth vs
        %     ln(E or Lu) relationship for QA/QC
        for lmbd=1:137
            ed_mdl=[];
            lu_mdl=[];
            eu1_mdl=[];
            eu2_mdl=[];
            
            if ~isempty(pres_index)  % Test to make sure there are data
                if ~isempty(ed_corr_es)
                    ed_mdl=fitlm(pres_interp_corr{pro_index}(pres_index),log(ed_corr_es(pres_index,lmbd)));
                    rsqr_ed(lmbd)=ed_mdl.Rsquared.Ordinary;
                    ed_coeff=ed_mdl.Coefficients.Estimate;  %Intercept is coefficient 1 and slope is coefficient 2
                else
                    ed_coeff=NaN(2,1);
                end

                if ~isempty(lu_corr_es)
                    lu_mdl=fitlm(pres_interp_corr{pro_index}(pres_index),log(lu_corr_es(pres_index,lmbd)));
                    rsqr_lu(lmbd)=lu_mdl.Rsquared.Ordinary;
                    lu_int=lu_mdl.Coefficients.Estimate(1);
                    lu_coeff=lu_mdl.Coefficients.Estimate;  %Intercept is coefficient 1 and slope is coefficient 2
                else
                    lu_coeff=NaN(2,1);
                end

                if ~isempty(eu1_corr_es)
                    eu1_mdl=fitlm(pres_interp_corr{pro_index}(pres_index),log(eu1_corr_es(pres_index,lmbd)));
                    rsqr_eu1(lmbd)=eu1_mdl.Rsquared.Ordinary;
                end

                if ~isempty(eu2_corr_es)
                    eu2_mdl=fitlm(pres_interp_corr{pro_index}(pres_index),log(eu2_corr_es(pres_index,lmbd)));
                    rsqr_eu2(lmbd)=eu2_mdl.Rsquared.Ordinary;
                end

                if ~isempty(ed_mdl)
                    k_ed(lmbd)=-ed_mdl.Coefficients.Estimate(2);
                    k_lu(lmbd)=-lu_mdl.Coefficients.Estimate(2);
                    ln_ed_0_extrap=ed_mdl.Coefficients.Estimate(1);   
                    ln_lu_0_extrap=lu_mdl.Coefficients.Estimate(1);  
                    ed_0(lmbd)=exp(ln_ed_0_extrap);
                    lu_0(lmbd)=exp(ln_lu_0_extrap);
                end
    
                if ~isempty(eu1_mdl)
                    k_eu1(lmbd)=-eu1_mdl.Coefficients.Estimate(2);
                end
    
                if ~isempty(eu2_mdl)
                    k_eu2(lmbd)=-eu2_mdl.Coefficients.Estimate(2);
                end
    
                if ~isempty(eu1_corr_es)
                    ln_eu1_0_extrap=eu1_mdl.Coefficients.Estimate(1);   %polyval(p_eu,0);
                    eu1_0(lmbd)=exp(ln_eu1_0_extrap);
                end
                if ~isempty(eu2_corr_es)
                    ln_eu2_0_extrap=eu2_mdl.Coefficients.Estimate(1);   %polyval(p_eu,0);
                    eu2_0(lmbd)=exp(ln_eu2_0_extrap);
                end
            else
                rsqr_ed(lmbd)=NaN;
                ed_coeff=NaN(2,1);
                rsqr_lu(lmbd)=NaN;
                lu_coeff=NaN(2,1);
                rsqr_eu1(lmbd)=NaN;
                eu1_int=NaN;
                rsqr_eu2(lmbd)=NaN;
                eu2_int=NaN;
                k_ed(lmbd)=NaN;
                k_lu(lmbd)=NaN;
                ed_0(lmbd)=NaN;
                lu_0(lmbd)=NaN;

            end

        end
        
        % Calculate water leaving radiance and Rrs
        lw_0=0.543.*lu_0;  % (Zibordi et al. 2012, Ocean Sci. 8, 567586, 2012 (www.ocean-sci.net/8/567/2012/)
        lw_0_interp=interp1(lu_lambda',lw_0,ed_lambda');
        rrs=lw_0_interp./es_corr_interp{pro_index}(1,:);
        
        pro_group_struct{groupn}.ed_corr_es{loop_index}=ed_corr_es;
        pro_group_struct{groupn}.es_corr_interp{loop_index}=es_corr_interp{pro_index};
        pro_group_struct{groupn}.lu_corr_es{loop_index}=lu_corr_es;
        pro_group_struct{groupn}.eu1_corr_es{loop_index}=eu1_corr_es;
        pro_group_struct{groupn}.eu2_corr_es{loop_index}=eu2_corr_es;
        
        pro_group_struct{groupn}.k_ed{loop_index}=k_ed;
        pro_group_struct{groupn}.k_lu{loop_index}=k_lu;
        pro_group_struct{groupn}.k_eu1{loop_index}=k_eu1;
        pro_group_struct{groupn}.k_eu2{loop_index}=k_eu2;
        
        pro_group_struct{groupn}.ed_0{loop_index}=ed_0;
        pro_group_struct{groupn}.lu_0{loop_index}=lu_0;
        pro_group_struct{groupn}.eu1_0{loop_index}=eu1_0;
        pro_group_struct{groupn}.eu2_0{loop_index}=eu2_0;
        pro_group_struct{groupn}.lw_0{loop_index}=lw_0;
        pro_group_struct{groupn}.rrs{loop_index}=rrs;

        pro_group_struct{groupn}.ed_lambda{loop_index}=ed_lambda;
        pro_group_struct{groupn}.lu_lambda{loop_index}=lu_lambda;
        pro_group_struct{groupn}.eu1_lambda{loop_index}=eu1_lambda;
        pro_group_struct{groupn}.eu2_lambda{loop_index}=eu2_lambda;
        pro_group_struct{groupn}.es_lambda{loop_index}=es_lambda;

        pro_group_struct{groupn}.rsqr_ed{loop_index}=rsqr_ed;
        pro_group_struct{groupn}.rsqr_lu{loop_index}=rsqr_lu;
   end
    
end

save([inputfolder,cruise_txt,'_hyperpro_processed.mat'],'pro_group_struct');

disp('Hyperpro processing completed');






